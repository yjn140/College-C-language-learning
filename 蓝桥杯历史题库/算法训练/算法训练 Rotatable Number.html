<head>
    <meta charset="UTF-8">
<title>算法训练 Rotatable Number</title>
<link rel="stylesheet" href="../css/main.css">
</head>
 <p>【问题描述】<br />
Bike是个十分喜欢数学的聪明孩子。他发明了&ldquo;可旋转数&rdquo;，其灵感来自于142857。<br />
正如你所见，142857是一个十分神奇的数，因为所有从它通过旋转得到的数都是它自己乘以1,2,3...,6（从1到数的长度）。旋转一个数就是将它的最后一位数字放到最前面。比如说，通过旋转12345你能够得到这些数：12345,51234,45123,34512,23451。值得一提的是这里允许有前导0。因而4500123和0123450都能够通过旋转0012345得到。你可以看看142857满足条件的原因了。下面的6个方程都在十进制下成立：<br />
142857 * 1 = 142857;<br />
142857 * 2 = 285714;<br />
142857 * 3 = 428571;<br />
142857 * 4 = 571428;<br />
142857 * 5 = 714285;<br />
142857 * 6 = 857142<br />
现在，Bike提出了一个问题。他将&ldquo;可旋转数&rdquo;推广到了任意进制b。如上所示，142857是十进制下的一个&ldquo;可旋转数&rdquo;。另外一个例子是二进制下的0011。下面的4个方程都在二进制下成立：<br />
0011 * 1 = 0011;<br />
0011 * 10 = 0110;<br />
0011 * 11 = 1001;<br />
0011 * 100 = 1100<br />
他想要找到最大的b(1 &lt; b &lt; x)，满足在b进制下存在一个长度为n的正&ldquo;可旋转数&rdquo;（允许有前导零）。<br />
【输入格式】<br />
仅一行包含两个用空格分隔的整数n,x。<br />
【输出格式】<br />
一行一个整数，表示你找到的最大的b。如果不存在满足条件的b，输出-1。<br />
【样例输入I】<br />
6 11<br />
【样例输出I】<br />
10<br />
【样例输入II】<br />
5 8<br />
【样例输出II】<br />
-1<br />
【数据规模和约定】<br />
对于20%的数据，n &lt;= 10, x &lt;= 15<br />
对于50%的数据，x &lt;= 10<br />
对于100%的数据，1 &lt;= n &lt;= 5 * 10^6，2 &lt;= x &lt;= 10^9</p>