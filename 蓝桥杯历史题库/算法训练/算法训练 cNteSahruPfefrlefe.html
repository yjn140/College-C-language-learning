<head>
    <meta charset="UTF-8">
<title>算法训练 cNteSahruPfefrlefe</title>
<link rel="stylesheet" href="../css/main.css">
</head>
 <p>【问题描述】<br />
Preston Digitation是一个对纸牌魔术很专业的魔术师。完美洗牌这件事情Preston不能做得恰到好处。<br />
完美洗牌是将52张牌分成两半然后完美的交叉起来，所以牌的下半部分最上面的牌将被放在洗牌后的牌顶。<br />
如果我们把这些牌标为0(牌顶)-51(牌底)，那么一次完美洗牌后的结果会像这样：<br />
26 0 27 1 28 2 29 3 30 4 31 5 32 6...51 25<br />
Preston发现每次洗牌他最多犯一次错误。例如，2号牌跟28号牌会互换，结果像这样：<br />
26 0 27 1 2 28 29 3 30 4 31 5 32 6...51 25<br />
这些对两个相邻卡牌的交换是Preston犯的唯一一个错误。一次洗牌后，他会很容易发现他在哪里和为什么犯这个错误，但是在几次洗牌后这会变得越来越困难。<br />
他希望你写一个程序来确定他的错误。<br />
【输入格式】<br />
输入包含多组数据。<br />
第一行一个整数表示数据组数。<br />
对于每组数据将有一行52个整数表示经过1到10次洗牌后的牌组。<br />
【输出格式】<br />
对于每组数据，输出这组数据序号。<br />
接着是洗牌的次数。<br />
如果没有错误<br />
输出&quot;No error in any shuffle&quot;<br />
否则，对于每次错误<br />
输出&quot;Error in shuffle N at location M&quot;<br />
N表示犯错误的洗牌次数，M表示交换的两张牌的位置。洗牌次数从1开始计算，而位置值取第一张牌所在位置(牌顶为0)，在上面的例子中，卡牌位置为4和5(编号为2和28)是错误的，所以在这例中我们用4。错误按洗牌次数N递增输出，如果某次洗牌没有错误则不输出它。如果有多种方案，选择错误数最小的方案输出(数据保证有一个最小错误方案)。<br />
【样例输入】<br />
3<br />
26 0 27 1 2 28 29 3 30 4 31 5 32 6 33 7 34<br />
8 35 9 36 10 37 11 38 12 39 13 40 14 41 15<br />
42 16 43 17 44 18 45 19 46 20 47 21 48 22<br />
49 23 50 24 51 25<br />
26 0 27 1 28 2 29 3 30 4 31 5 32 6 33 7 34<br />
8 35 9 36 10 37 11 38 12 39 13 40 14 41 15<br />
42 16 43 17 44 18 45 19 46 20 47 21 48 22<br />
49 23 50 24 51 25<br />
49 26 43 40 37 34 31 28 25 22 19 16 13 10<br />
7 4 1 51 48 45 42 39 36 33 24 27 30 21 18<br />
15 12 9 6 3 0 50 47 44 41 38 35 32 29 46<br />
23 20 17 2 11 8 5 14<br />
【样例输出】<br />
Case 1<br />
Number of shuffles = 1<br />
Error in shuffle 1 at location 4<br />
Case 2<br />
Number of shuffles = 1<br />
No error in any shuffle<br />
Case 3<br />
Number of shuffles = 9<br />
Error in shuffle 3 at location 3<br />
Error in shuffle 7 at location 11<br />
Error in shuffle 8 at location 38<br />
【数据规模和约定】<br />
&nbsp;见题目描述<br />
&nbsp;</p>